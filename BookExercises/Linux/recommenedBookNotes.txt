CHAPTER 10 CASE STUDY 1: UNIX, LINUX AND ANDROID
    Other Variations of UNIX
        AIX
        FreeBSD
        HP-UX
        SCO UNIX
        System V
        Solaris
    Was pet project of Ken Thompson
    UNICS - (Uniplexed Information and Computing Service)
10.2 LINUX OVERVIEW
    -Principle of least surprise: Let everything be simple, elegant and consistent
    -Every program should do just one thing and do it well
    -Avoid useless redundancy
    10.2.2 Interfaces to Linux
        User Interface --> Library Interface --> System Call Interface
        Users--> Standard Utility Programs(shell, editors) --> Standard Library (open, close, read, write, fork) --> Linux OS (process management, memory management, I/O) --> Hardware (CPU, memory)
        |---------------------User MODE-------------------------------------------------------------------------|---------------------------Kernel Mode-------------------|

       - SYSTEM CALLS
            - READ, WRITE, OPEN, CLOSE, FORK etc
            - Programs make system cals by putting arguments in registers or on the stack and issuing trap instructions to switch from user to kernel mode
            - There is no way to write a TRAP instruction in C but a library is provided with one procedure per system call
            - Procedure are written in assembly but can be called from C
                - each first puts its arguments in the proper place then executes the trap instruction
            - The library interface NOT the system call interface is specified by POSIX 
            - POSIX = operating system standards 1003.2
        - Library Calls
            - command processor (shell), compilers, editors, text-processors and file manipulation utilities
        - User interface
            - Similar to the first GUIs with an added Mouse oriented keyboard interface rather than keyboard oriented
            - Popular Desktop Enviroments for Linux
                - GNOME (GNU Network Object Model Enviroment)
                - KDE (K Desktop Enviroment)
            - GUIs supported by X Windowing System or X11 or X
                - Defines communication and display protocols for manipulating windows on bitmap displays
                - X Server controls devices like keyboard, mouse and screen
                - X redirects input to or accepts output from client program
                - Can be started via command line, but is typically started during the boot process by a display manager
                - xterm = terminal emulator 
    10.2.3 THE SHELL
        Command line interface
        - when a user types a command line
            -Shell extracts first word
            - assumes word is a program
            - searches for program
            - runs programs
            - suspends itself until the program terminates
        - flags - optional value
        - magic characters or wildcards
            - * = all possible strings
            - ? = matches any one character
            - [ape]* = matches all files beginning in 'a' 'p' or 'e'
        - When it opens shell automatically has access to a file called Standard Input, Standard Output and Standard Error
        - CTRL-D = end of file
        < - redirect standard in
        > - redirect standard out
        - Filter = program that reads from stdin and writes to stdout
        - pipe symbol 
        - Pipeline - collection of commands connected by pipe symbols
        - To run a process in the background follow it's command with an &
        - Files containing shell commands are called shell scripts
    10.2.4 LINUX UTILITY PROGRAMS
        Six Categories
        1. File and Directory Manipulation Controls
            cp
            mv
            mkdir
            rm
            chmod
            rmdir
            cat
            ls
        2. Filters 
            grep
            sort
            head
            tail
            cut 
            paste
            od, convert binary input to ASCII text in octal, decimal or hexadecimal
            tr, character translation (like from lower to upper case)
            pr, format output for printer
        3. Program Development Tools, such as editors and compilers
            gcc, calls the C compilier
            ar, collects library procedures into archive files
            make, used to maintain large programs whose source code consists of multiple files
    10.2.5 Kernel Structure
        Structures
        Kernel sits on hardware and enables interactions with I/O, Memory and conrols CPU access
            SYSTEM CALLS -- All systems calls come here causing a trap which switches the execution from user to protected kernel mode then passes control to the I/O., Process or Memory Managment
                I/O Component - all components responisble for interacting with devices, performing network and I/O operations
                    -Virtual File System --- HIGHEST LEVEL 
                        -Terminals 
                            -- character device drivers (lowest level)
                                - Seeks and Random Access not allowed
                                    -Can be used to get every keystroke
                                        -tty (Raw Terminal I/O)
                                    -Or can be line oriented
                                        - users must enter whole line before sending it to program
                        -Sockets--Network Protocols
                            --Network Device Drivers (lowest level) - (technically character devices)
                                - Most linux systems contain ful functionality of a hardware router within kernel
                                - Above hardware is IP, TCP, Application layer protocols (with sockets(Top Layer))
                                - allows for programs to create sockets for particular networks and protocols
                                - Gets back a fd for each socket to use later
                        -File Systems--
                            Linux has multiple file systems coexisting
                            Generic Block Layer
                                Provides an abstraction used by all those file systems to hide architectural differences in hardware devices
                                --I/O Scheduler
                                    Responsible for ordering and issuing disk-operation requests to conserve wasteful disk head movement
                                    --Block Device Drivers (lowest level) 
                                        - Seeks and Random Access Allowed
                Memory Management Component
                - Maintains virtual to physical mappings, maintains a cache of recently accessed pages and implements page-replacement and on-debmand bringing in new pages of needed code and data into memory
                    - Virtual Memory
                    - Paging page replacement
                    - Page Cache
                Process Management Component
                - Creates and terminates processes
                    - Signal Handling
                    - Process / Thread creation and Termination
                    - CPU Scheduling
            INTERRUPTS
                - Primary way for interacting with devices
            DISPATCHER
                - Occurs when the interrupt happens
                - Stops the running process, saves its state in the kernel, starts the correct driver
        4. Text Processing
        5. System Administration
        6. Miscellaneous


10.3 PROCESSES IN LINUX

10.3.1 Fundamentals
    - Each process runs a single progra and has a single thread of control
    - Daemon - background process
    - cron daemon - wakes up once per minute to check if there is work ti di
    Process Creations
        - fork system call creates exact copy
        - parent and child
        - each have their own memory images
        - if parent or child changes any variables they wont be visible to the child and vice versa
        - Fork system call returns a 0 to the child and the child's PID to the parent..both check the return value then act
        - getpid = system call that provides childs PID to child
    - Processes communicate via pipes
        - when a process tries to read from an empty pipe it is blocked until data is available
    - Processes also communicate via software interrupts or signals
        - When signal arrives control goes to the handler, when handler finishes control goes back
        - A process can only send signals to members of its process group
            Process group - parent and ancestors, siblings and children
            - A process can send a signal to all members with a single system call


10.3.2 Process Managment System Calls in Linux
    After fork and the return of the child PID to the parent waitpid system call occurs
    --waitpid system call --
        - three parameters
            1. allows the caller to wait for a specific child, if it is -1 any child will do
            2. Address of a variable that will be set to the child's exit status
            3. Determines whether the caller blocks or returns if no child is already terminated
    --execve system call --
        - three parameters
            1. name of the file to be executed
            2. a pointer to the argument array
            3. a pointer to the enviroment array
        -main(argc, argv, envp)
            - argc = count of cl items
            - argv = pointer to array
            - envp = pointer to env array
    -- exit() --
        - if child exits and parent has not waited then zombie
    -- alarm(seconds) --
        a process may need to do something after a specific time period at which point a sig alarm is used
        Only one alarm can be run at a time
    -- pause() -- 
        Only call with alarm set
        Suspends process until next signal which is done by the alarm

    -- PROCESS SYSTEM CALLS --
    pid = fork() -- create a child process identical to parent
    pid = waitpid(pid, &statloc, opts) -- wait for a child to terminate
    s = execve(name, argv, envp) -- replace a process' core image
    exit(status) -- terminate process execution and return status
    s= sigaction(sigm &act, envp), define action to take on signals
    s= sigreturn(& context), return from a signal
    s= sigprocmask(how, &set, &old), examine or change the signal mask
    s= sigpending(set), get the set of blocked signals
    s= sigsuspend(sigmask), replace the signal mask and suspend the process
    s= kill(pid, sig), send a signal to the process
    residual = alarm(seconds), set the alarm clock
    s= pause(), suspend the caller until the next signal

10.3.3 IMPLEMENTATION OF PROCESSES AND THREADS IN LINUX
    - Kernel represents processes as tasks via task_struct
    - A process descriptor of type task_struct is resident in memory at all times
     -- task_struct contains--
        - info needed for the kernel's managment of all processes
            - scheduling parameters
            - lists of open file descriptors etc
        - descriptor and memory for the kernel mode stack for the process are created upon process creation
    - kernel organizes all processes in a doubly linked list of task structures
    - PID is mapped to address of the TASK STRUCTURE for immediate access
    - TASK STRUCTURES -
        - contain pointers to other DS or segments like those containing open files
        - some segments related to user-level stucture (can be swapped or paged out to preserve memory)
    - INFORMATION IN PROCESS DESCRIPTOR -
        1. Scheduling parameters - niceness CPU time consumed, time sleeping
        2. Memory Image - pointers to text, data and stack segments or page tables, if text is shared it points to shared text table
        3. Signals - masks showing which signals are being ignored, which are being caught, which are blocked etc.
        4. Machine Registers - when trap to kernel, machine registers are saved here
        5. System call state - info about current system call, includes parameters and results
        6. File Descriptor Table - fd is used as an index to locate in-core data structure (inode)
        7. Accounting - pointer to a table that tracks user and system CPU time by process, some systems impose limits
        8. Kernel Stack - fixed stack for use by the kernel part of the process
        9. Misc - current state, event being waited for, time until alarm, PID, PID or parent, user and group id


    PROCESS CREATION IN LINUX
        0. fork syste call is executed
        .5 calling process traps to the kernel and creates task structure and other data stuctures like Kernel mode stack and a thread_info structure
        1. new process descriptor and user area are created for the child process and filled in by parent
        1.2 Linux looks for an available PID and updates PID hash-table entry to point to new task structure (process descriptors may be chained)
        2. Child is given a PID
        3. Child memory map is set up
            -- childs page tables point to parents as read only.. 
            -- if a write is attempted  then kernel allocates a new copy so no extra memory taken
            -- called COPY ON WRITE
        4. Child is given shared access to parent's files

        5. Childs registers are set up and it is ready to run
        6. Code running in child does an exec() system call giving command name
        7. kernel finds and verifies the executable file
        8 . Kernel copies the arguments and enviroment string and release the old address space and its page tables
        9. new address space is created and filled in
            1. new page tables set up to indicate no pages are in memory except for a stack page
            2. A page fault will occur which will cause the first page of code to be paged in from the executable file
            3. Args and enviromental strings copied to new stack
            4. signals reset
            5. registers initialized to all zeros
 
LS COMMAND ON PAGE 743!!!

Threads in linux
- Classically when a new thread was created the original threads and the new one shared everything but the registers
    - specifically
        - fd for open files
        - signal handlers
        - alarms
        - other global properties were per process, not per thread
-Clone system call - made it possible for for each aspect to be process or thread specific
    pid = clone(function, stack_ptr, sharing_flags, arg)
    - creates new thread in current or new process
        - if current it shares address space and each write is available to all other threads in the process
        - if address space not shared new thread gets exact copy of address space but new writes not visible
    - new thread gets its own private stack initialized to stack_ptr
    - new thread begins executing at function with arg as its only parameter
    - sharing flags parameter
        - determines whether the new thread copies some data stucutre or shares it with the calling thread
- A linux program that takes advantage of this is no longer portable to UNIX
- UNIX means 1 PID per process regardless of threading. Linux has a TID
    - if precess is started that shares nothing with its creator then PID is set to a new value, otherwise the task gets a new TID but inherits the PID...so all threads has same PID as first


10.3.4 Scheduling in Linux
    Linux threads are Kernel Threads so scheduling based on threads NOT processes

    Classes of Threads
        1. Real - time FIFO
            - highest priority
        2. Real time round robin
            - have time quanta associated with them...so each is run for its quantum
        3. Time sharing
   -- nice system call --
    Better than normal service is -1 to -20

   --runqueue - data structure used by the scheduler to track all runnable tasks in the system
   O(1) Scheduler - able to perform task managment operations in constant time independent of total number of tasks on system
        -Two arrays = active and expired
        - selects task from the highest priority list in active 
            -if quantum expires move to expired
            - if blocked via I/O event - placed back in active, timeslice decremented then placed in expired
            - when no tasks in active, swap pointers so expired become active
    -Dynamic Priority 
        1) reward interactive threads
        2) Punish CPU hogs
    - The heuristics used to determine interactivity of a task and priority level subsequently were complex and imperfect which caused poor performance for interactive tasks

Completely Fair Scheduler (CFS) - default scheduler for non-real time tasks
    - uses red/black tree as the runqueue data structure
        - tasks ordered based on time they spend running on the CPU
        - CFS schedules task with lowest runtime, typically leftmost node
        - periodically checks against current leftmost node
        - if more than the task will be placed in appropriate place in tree and CPU will be given the new leftmost node
        - To account for niceness CFS changes the virtual time passes so lower priority tasks have time run quicker so they are reinserted sooner
        - selecting a node is done in constant time and inserting a task is done in O(log n) time
-->Scheduler only considers runnable tasks
-->Nonrunnable or waiting tasks are places in the waitqueue
    - a waitqueue is associated with each event tasks may wait on

10.3.5 BOOTING LINUX
    1. BIOS perform Power On Self Test (POST)
    2. First sector of the boot disk MBR (Master Boot Record) is read into a fixed memory location and executed
        2.1 Contains a small 512 byte program called boot from the boot device
        2.2 boot program copies itself to a fixed high memory space to free up low memory space for the OS
    3. boot opens the bootloader or GRUB
    4. boot reads in th eoperating system kernel and reads into it
    5. The kernel:
        5.1 sets up the kernel stacks
        5.2 identifies the CPU type
        5.3 Calculates amount of RAM
        5.4 Disabes interrupts
        5.5 Enables the MMU 
        5.6 Calls the C-Language main procedure to start the main part of the program
    6. Kernel data structures are allocated
        6.1 Like the page cache and page data structures...each depend on amount of RAM available
    7. System begins autoconfiguration based on I/O devices and other devices it does this with dynamic loading of devices
        7.1 Dynamic device loading is when a single binary is shipped with divergent configurations which automatically loads drivers it needs
    8. Start init by setting up its stack then running it
    9. Init checks flags to see if it is single or multiuser
        9.1 If single user then it executes the shell and waits for the process to exit
        9.2 If mulit user it executes system initialization shell script and does fsck, mounts additional file systems, starts the daemon processes
            9.2.1 reads etc/ttys (lists terminals and their processes)
            9.2.2 For each terminal it forks off a copy of itself then executes getty
                9.2.2.1 Getty sets the line speed then displays login: on the terminals screen to get users login
                9.2.2.2 After login getty terminates by executing /bin/login
    10. Login program asks for password, encrypts it and checks it against /etc/passwd and if correct replaces itself with the users shell


10.4 MEMORY MANAGEMENT IN LINUX
10.4.1 Fundamental Concepts
    Each process has an address space with three parts:
        Text
            Contains machine instructions that make executable code
            Produced by the compiler and assembled by translation
            Normally read-only
        Data
            Contains storage for all variables, strings, arrays and other data
            Two parts
                Initialized - contains varibles and compiler constants
                unitialized - known as BSS (block started symbol)
            Data segment can change - can grow and shrink dynamically
            System call brk allows a program to set its memory
            Range of dynamically allocated memory areas in the process is called the heap
        Stack
            Starts at top of address space and grows down
            If stack grows below then hardware fault occurs and the OS lowers the bottom of the stack by one page
            At program start stack is not empty, it contains env variables and command line used to invoke it
                So program can easily parse its arguments
            Processes in Linux can access file data through memory mapped files
                - makes it possible to map a file onto a portion of the processes address space which makes random access easier
                - two or more processes can map in the same file at the same time -- writes to one are immediately available to the other
10.4.2 MEMORY MANAGEMENT SYSTEM CALLS IN LINUX
    POSIX does not specify system calls for memory management
    Linux does however
        s = bkr(addr) ... changes the data segment size
        a = mmap(addr, len, prot, flags, fd, offset) ... maps a file in
            addr is the addresss the file is mapped (must be a multiple of the page size)
                if 0 the system determines the address
            len is how many bytes to map
            prot is the protection (read, write, execute)
            flags -- private or sharable and whether adr is a requirement or hint
            fd -- file descriptor
            offset -- where in the file to begin mapping
        s = unmap(addr, len) ... unmaps a file
10.4.3 MEMORY MANAGEMENT IMPLEMENTATION
    Each process gets 3 GB of virtual space  and 1 GB reserved for page tables and other kernel data on 32 bit machine
    64 bit machines only up to 48 bits used for addressing meaning a limit of 256 TB for the size of addressable memory 64 - 48 = 16 split between kernel and user meaning 128 each per process
        - address space created on exec system call
    Physical Memory Management
        Memory Zones:
            1. ZONE_DMA and ZONE_DMA32
                pages used for DMA from 0-16 MB on 32 bit 
            2. ZONE_NORMAL
                regularly mapped pages
            3. ZONE_HIGHMEM
                pages with high-memory addresses which are not permanently mapped anything above 896MB in x86 systems
    Main Memory in Linux has three parts
        First two - both pinned in memory and never paged out
            Kernel - maintains a map of the main memory and use of physical memory in the system
                keeps an array of page_descriptors call mem_map
                    page_descriptor
                        contains a pointer to the address space it belongs to
                zone descriptors for each zone
                node descriptor - used to differentiate between physical memory on different nodes
            Memory Map
    Memory Allocation Mechanisms
        - Page Allocator - main mechanism for allocating new page frames of physical memory
            - operates using the buddy algorithm
            - buddy algorithm
                - take contigous memoory of 64 pages, round up request to closest power of two (so 7 is 8 or 14 is 16), divide lower piece by powers of two until desired pages is reached
        - slab allocator
            - takes chuns using the buddy algorithm then carves slabs from them and manages the smaller units separately
        - vmalloc
            - used when memory needs to be allocated contiguosly in virtual space but not physical
10.4.4 Paging In Linux
    PAGE = main memory management unit
        - alll memory-management components operate on a page granularity
        - Basic Idea
            - a process need not be entirely in memory to run
        - Implemented by:
            The Kernel
            The Page Daemon - process 2 
                - if it sees the list of free memory pages are two low it starts freeing pages
        - at boot time init starts up a page daemon for each meory node and configures them to run periodically called:
            kswapd
                - checks to see if there are enough free pages available, if there is enough memory it goes back to sleep else:
                    - reclaims up to 32 pages (limit is to control I/O pressure)
                    - first tries easy pages then the harder ones
                        - easy = discardable and unreferenced
                            - pages with backing store which have not been referenced recently
                            - user pages
                    - if page is invalid, absent from memory, shared, locked in memory or being used for DMA it is skipped
                - During reclaimation pages are oved between active and inactive and referenced or not
                - if inactive flag and unreferenced flags are set then the pages are set for eviction
       - pdflush
            -set of background daemon threads
            - either wake up to write back to disk very old pages or are explicitly awakened by the kernel when memory levels fall below a certain threshold

10.5 INPUT/OUTPUT IN LINUX
10.5.1 Fundamental Concepts
    I/O Devices include disks, printers, networks
    - Integrated into the file system as special files
        -Two Types
            - Block Files
                - consists of a sequence of numbered blocks
                - each block can be individually addressed and accessed
            - Character Files
                - used for devices that input or output a character stream
                - Character special files can be customized to make system calls that are not permitted in block files
        - Each special file has a device driver
            - major device number - for identification
            - if driver controls multiple devices like two disks of the same type then it has a minor device number too
            - some drivers control multiple devices like /dev/tty controls the keyboard and the screen and is regarded as a signel device the terminal
    - each devices is assigned a path name in /dev
        - disk = /dev/hd1
        - printer = /dev/lp
        - network = /dev/net
        - Can be treated like regular files so cp file /dev/lp will send that file to the printer if the user has access to /dev/lp
10.5.2 Networking
    Socket is the key -- analogous to mailboxes and telephone wall sockets in that they allows users to interface to the network
        - Sockets can be created and destroyed dynamically
        - Sockets supports a specific type of networking specified on creation:
            1. Reliable connection-oriented byte stream
                -- allows tow processes on different machines to establish a pipe between them
            2. Reliable connection- oriented packet stream
                -- preserves packet boundaries
                    - Type 1 and Type 2 
            3. Unreliable packet transmission
        - Once socket have been created on both source and destination computers a connection can be established between them
            - One makes a listen call
            - The other makes a connect call
10.5.3 INPUT/OUTPUT SYSTEM CALLS
    - Used to either get or set the terminal speed ir setting and reading back all the special characters used for erasing characters and lines, interrupting processes etc.
    SYSTEM CALLS:
        s = cfsettospeed(&termios, speed) -- set output speed
        s = cfsettispeed(&termios, speed) -- set input speed
        s = cfgettospeed(&termios, speed) -- get output speed
        s = cfgettispeed(&termios, speed) -- get input speed
        s = tcssetattr(fd, opt, &termios) -- set the attributes
        s = tcgetattr(fd, &termios) -- get the attributes

10.5.4 Implementation of I/O in Linux
    - Implemented by a collection of drivers
    - Drivers function
        -- isolate the rest of the system from the hardware
    - When user accesses the special file
        - 1. file system determines the major and minor device numbers and whether it is block or character
        - 2. Major number used to index into one of two internal hash tables containing data structures for character or block devices
        - 3. Structure contains pointers to perform procedures to call on the device like read, write, open etc. with minor device as parameter
    - All character devices have the following functions/ procedures ...though not all use them
        - Open
        - Close
        - Read
        - Write
        - loctl
        - Other
    - Driver split into two parts both part of the Kernel and run in Kernel mode
        - Top half - runs in context of the caller and interfaces with the rest of linux
        - Bottom half - runs in kernel and interfaces with the device
    - I/O System separated into two components
        - Handling of block special files
            - cache between disk drivers and file system to prevent disk access that isn't needed
            - if not in cache it is read from disk into cache
            - when a write occurs it goes back to the cache not the disk
            - I/O Scheduler
                - reorders and bundles read/write requests to block devices
        - Handling of Character special files

10.5.5 Modules in Linux
    Loadable modules were the solution to bridging the gap between devices and linux when linux moved from minicomputers to pcs
    - When module is loaded:
        1. It has to be relocated as it is loaded
        2. System has to check to see if the resources the driver needs are available
        3. Any interrupt vector must be set up
        4. The appropriate driver switch table has to be updated to handle the new major device type
        5. Driver is allowed to run to perform any device specific initialization


10.6 THE LINUX FILE SYSTEM
Fundamental Concepts
Linux File
    -Sequence of 0 or more bytes containing arbitrary information
    - Files grouped together in directories for convienience
    - Major directories
        - /bin -- Binary/Executable Files
        - /dev -- special files for I/O devices
        - /etc -- Misc system files
        - /lib -- Libraries
        - /usr -- user directories
    - Absolute path - get file starting from root "/"
    - Relative path = path from the working directory
        - Solution to getting files that belong to a different user is by using a link
    - Block special files
        - /dev/hd1 can be used to read and write raw disk partitions without regard for the file system
            - a seek to byte k followed by a read will begin reading from k on the partition ignoring i-node and file structure
            - used for paging and swapping by programs that lay down file systems like "mkfs" or fix them "fsck"
    - Character special files
    - LINUX SOLUTION TO MULTIPLE DISKS
        - Allow one disk to be mounted to anothers file system
    ---Locking---
        - Two or more processes using the same resource which may lead to race conditions
        - POSIX allows processes to lock a single byte up to an entire file, Caller must specify the file, the starting block and the number of bytes
        - Two Kinds of locks
            - Shared Locks
                - multiple shared locks can be placed on a file
            - exclusive locks
                - no other locks allowed

10.6.2 FILE SYSTEM CALLS IN LINUX
    fd = creat("abc", mode): -- creates a file and sets the protection mode
    fd = open(file, how, ...) -- open file for reading, writing or both
    s = close(fd) -- close an open file
    n = read(fd, buffer, nbytes) -- read data from a file into a buffer
    n = write(fd, buffer, nbytes) -- write data from a buffer into a file
    position = lseek(fd, offset, whence) -- move the file pointe
        - offset = file position
        - whence = file position relatie to the beginning, current or end of the file
        - just updates the current file position (which is a number in memory)
    s = stat(name, &buf) -- get a file's status information
    s = fstat(fd, &buf) -- get a file's status information
    s = pipe(&fd[0]) -- create a pipe
    s = fcntl(fd, cmd, ...) -- File locking and other operations
    --- STAT SYSTEM CALL ---
        Tracks:
            File mode (regular, directory, special)
            Size
            Time of last modification
        FIELDS RETURNED
            - Device file is on
            - I- node number (which file on the device)
            - File Mode
            - Number of links to the file
            - id of file owner
            - group file belongs to
            - file size (in bytes)
            - creation time
            - time of last access
            - time of last modification
    --- FSTAT SYSTEM CALL --
        Same as stat but operates on open file whose name may not be known rather than a path name
    --- PIPE SYSTEM CALL ---
        used to create shell pipelines..creates pseudofile which buffers data between pipeline components and returns fds for both reading and writing to the buffer
    --- FCNTL SYSTEM CALL ---
        Locks and unlocks files
        Apply shared or exclusive locks
---MORE SYSTEM CALLS---
    s = mkdir(path, mode) ..create new directory
    s = rmdir(path)... remove a directory
    s = link(oldpath, newpath) .. create a link to an existing file
    s = unlink(path) .. unlink a file
    s = chdir(path) .. change the working directory
    dir = opendir(path) .. open a directory for reading
    s = closedir(dir) .. close a directory
    dirent = readdir(dir) ... read one directory entry
    rewinddir(dir) .. rewind a directory so it can be reread
    --- LINK ---
        Creates new directory entry that points to an existing file
        When last link is removed file is deleted
    --- CHDIR ---
        Changes the working directory
    NO WAY FOR USERS TO WRITE IN A DIRECTORY
    NO WAY FOR USERS TO SEEK A SPECIFIC FILE IN A DIRECTORY BUT REWINDDIR ALLOWS AN OPEN DIRECTORY TO BE READ FROM THE BEGINNING

10.6.3 IMPLEMENTATION OF THE LINUX FILE SYSTEM
LINUX VIRTUAL FILE SYSTEM LAYER
    Defines a set of basc file-system abstractions and the operations which are allowed on these abstractions
    Four Main File System Data Structures supported by VFS
        - Superblock -- contains critical info about layout - specific file system -- destruction will render fs unreadable
            - read_inode, sync_fs
        - Dentry -- Directory enrty, single component of path -- created by system on the fly -- cached in dentry_cache
            - create, link
        - Inodes -- index nodes describe one specific file..directories and devices also have inodes maintained on physical disk
            - d_compare, d_delete
        - File -- In-memory representation of the open file..created in response to open system call..supports read, wrtie, sendfile, lock etc
            - read, write
    
    Elements of the OPERATIONS data structures for each of the four are pointers to functions in the underlying file system
    EXTENDED FILES SYSTEMS
        ext2
            Disk Partition Structure
                Block 0 - boot info
                Block 1 - superblock (info about layout including number of inodes, disk blocks and start of the list of free blocks)
                Block 2 - Group Descriptor - contains info about the location of the bitmaps, number of free blocks, inodes in the group, number of directories in the group
                Block 3 - Block Bitmap - two used to keep track of free blocks and free i-nodes...each is one block long...this limits a block group to 8192 blocks and 8192 inodes with 1 kb blocks
                Block 4 - Inode Bitmap - numbered from 1 to some maximum...128 bytes each and describes one file
                Block 5 - Inodes - contains accounting info and enough info to locate all the disk blocks that hold the files data
                Block 6 - Data blocks - all the files and directories are stored here ... if it spreads across more than one they don't need to be contiguous
            Bitmaps are used to quick decisions regarding where to allocate new file system data
            When a new file is made ext2 preallocates eight additional blocks for that file to minimize the change for fragmentation

            Accessing a file
                1. use open system call with file name
                2. path name parsed to extract individual directories
                3. if relative path -- lookup starts from pwd ...if absolute it locates root at inode 2
                4. finds inode for the first directory in the process descriptor
                5. Directory is either searched linearly or via the cache of recently accessed directories
                6. A dentry object is entered in the dentry cache for each of the path components and is searcher for the next path element entry
                7. Actual file inode is reached
                8. If file inode is present the system extacts inode and uses it as an index into the inode table to locate and bring it into memory
                9. System reads the file from the inode which contains first 12 blocks of the file 
                    -- if file is longer than 12 blocks the inode contains the adressof a single indirect block
                        - single indirect block contains disk address of more disk blocks
                            - if block is 1 KB and address is 4 bytes a single block can hold 256 addresses (1024/4)
                    -- double indirect block can be used too which can handle files up to 10 + 2 ^16 blocks
                    -- triple indirect block can be used to handle files up to 16GB....8 KB block sizes can support files up to 64 TB

            Directory file 
                - Consists of four fixed length fields and one variable length field
                    - Inode number
                    - entry size (in bytes with padding after the name)
                    - Type (F, D, etc)
                    - File Name Length
                    - FIle name
                - padding from removed files can be used on other subsequent entries
            
            Open-file-description table
                Table between file desciptor table and inode table for current file position...so if a process inherits a fd from a file it knows where to start
                - Allows child and parent to share 
                - Also gives unrelated files their own values
    LINUX EXT4 FILE SYSTEM
        Journaling File System
            - Maintains a journal and writes out all file system operations in sequential order
            - All changes to file system or metadata written out to prvent overheads of disk-head movement during random disk accesses
            - Once commited journal entries are deleted
        -Journal File
            - circular buffer
            - JBD (Journaling Block Device) used to perform journal reads/writes
                - Supports three main data structures
                    - log record
                        - describes low level file system operation
                        - related log entries are grouped in atomic operations
                    - atomic operation handle
                        - grouped log entries
                    - transaction
                        - collections of atomic operations that are stored consequtively
                - JBD may be configured to track all changes or just metadata to reduce overhead.
                    - reliability can be improved by checksumming
        - Uses Extents
            - represent contigous blocks of storage vs individual blocks like in ext2
            - does not require metadata for each block of data
            - reduces fragmentation for large files which means faster opertations and larger files
            - Block size 1KB increases max file size for 16 GB to 16 TB and max file size to 1 EB
    /PROC file system
        - for every process a directory is created in /proc

10.6.4 NFS: THE NETWORK FILE SYSTEM
    Joins file systems on separate machines into one logical whole
NFS ARCHITECTURE
    Each NFS server exports one or more directories
    List of exports is maintained in a file 
        Normally etc/exports
    Client can access these by mounting them then it becomes a part of the its directory hierarchy
NFS PROTOCOLS
    ------------Mounting------------------------------
        - Client can send a path neame to a server and request permission to mount that somewhere in its hierarchy
        - if path name is legal server returns a file handle
            - file handle includes:
                - file system type
                - disk
                - inode number of the directory
                - security info
        - reads and writes use the file handle
        - When linux boots it runs /etc/rc script before going multiuser 
            - This will mount remote file systems before allowing logins
        - automounting
            - allows a set of remote directories to be asscoiated with a local directory
            - none are mounted when the client is booted only the first time a remote file is opened...at which time the OS sends a message to each server and the first to reply is mounted
            - most often used for read-only file systems containing system binaries and other files that rarely change
     -----------Directory and File Access -------------------
        - Most system calls allowed except open and close
            - not necessary to open a file before reading it or close it when done
            - open call copies infrmation into internal system tables
            - lookup call (NFS alternative to open) - does not copy information
                - Advantage is server doesn't need to remember anything so no info is lost on a crash
                - Keep servers stateless
            - Locking can only be done on open files so locks cannot be used in the same way
                - NFS uses separate method for locking
NFS Implementation
    3 - Layer Implementation
        Top Layer - System Call Layer
            open, read, close
        Second Layer - Virtual File System Layer
            - Maintains a table with one entry for each open file
                - Has an entry virtual i-node or v-node for every open file
                    - used to tell whether the file is local or remote
    MOUNT, OPEN, READ PROCEDURE
    1. system admin or /etc/rc calls the mount program specifying the remote directory
    2. mount program parses the name and discovers the naes of the NFS server it is located on
    3. It then contacts the machine asking for a file handle for the directory
    4. if directory exists and is available the server returns a file handle for the directory
    5. Makes a mount system call and passes the handle to the kernel
    6. Kernel constructs a v-node for the directory and asks NFS to create a remote i-node (rnode) to hold the handle
        -- each v-node either points to a point to an r-node or a pointer to an i-node
        -- if it is remote the remote host and file handle can be located
    7. When open system call is sent during the directory parsing it finds the directory where the file system is mounted and sees it is remote
    8. Open call asks the NFS client to open the file
    9. NFS client looks for the remaining portion of the path and gets back a file handle for it
    10. Makes an r-node for the file reports back to VFS which puts in its tables a v-node for the file that points to the r-node
    11. Caller is given a file descriptor for the remote file which is mapped onto the v-node by tables in the VFS layer
    12. On read the file descriptor is used and the VFS layer locates the v-node which determines whether it is remote or local 
    13. Then the VFS sends a message to the server containing the file handle the offset and the byte count....byte transfers are done in large 8192 Byte chunks
    14. When request arrives at the server it is passed to the VFS layer which determines which local file system holds the file
    15. VFS layer then makes call to the local file system to read and return the bytes which are passed back to the client

    For writes a similar path is made, if a write system call is less than 8KB it waites until the chunk is full then sends it.
    If a file is closed all of its data are sent immideately

Caching
    Cacheing is used to increase efficiency
    Servers chache data to avoid disk accesses
    Clients maintain two caches
        - One for file attributes (inodes)
        - One for file data
    Problems with Caches
        - simultaneus access solutions
            - Each cache block is a timer 
            - If a cached file is opened a message is sent to the server to find when it was last modified, if it occured after the local copy was cached the cache copy is discarded and the new copy fetched
            - after the timer expires all modified blocks are sent to the server

NFSv4
    Stateful not stateless
    - permits open operations to be invoked on remote files since the remote NFS server will maintain all file-system-related structures including the file pointer.
    - read operations can be incrementally applied from the previous file pointer position

10.7 SECURITY IN LINUX
10.7.1 FUNDAMENTAL CONCEPTS
    UID - user id -- owner is the person who created the file
    GID - group id --system admin organizes people into groups
        - potential accesses are read, write and execute
        - 9 bits represent the access rights of a file
        - represented as binary 111000000 == rwx------
    Directories - x permissions are search permissions rather than execute permissions
    SETUID bit - when a program with the SETUID bit is executed the effective UID for the process becomes the UID of the executable file owner instead of the UID of the user who tried to execute it
    Many senstitive LINUX files are owned by root with the SETUID bit on...like the program that allows users to change their passwords "passwd"
        - though the program has full access to the password file it will only change the caller's password and not permit any other access to the file
    SETGID - same thing for groups --rarely used

SECURITY SYSTEM CALLS IN LINUX
    System Call                             Description
    s = chmod(path, mode)                   Change file protection
    s = access(path, mode)                  Check access using the real UID and GID
    uid = getuid()                          Get the real UID
    uid = geteuid()                         Get the effective UID
    gid = getgid()                          Get the real GID
    gid = getegid()                         Get the effective GID
    s = chown(path, owner, group)           Change the owner and the group
    s = setuid(uid)                         Set the UID
    s = setgid(gid)                         Set the GID

Implementation of Security in LINUX
    when a user logs in the login program .... called login (SETUID root) asks for name and password.
    - it hashes the password and looks for it in /etc/passwd via a hash match
    - if it matches then it looks in /etc/passwd for the users preferred shell then uses setuid and setgid to give itself the users UID and GID
    - opens the keyboard for standard input (fd0) standard output (fd1) and the screen for standard error (fd2) then executes the preferred shell and terminates itself
    - when a process tries to open a file the system first checks the protection bits in the file's inode against the callers effective UID and GID...if valid it opens, else it returns -1

THE END
